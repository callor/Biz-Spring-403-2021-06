# Spring JDBC Project

## java method 호출과 parameter(argument, 매개변수)
* method(함수)를 호출할때 단순히 호출하는 방법과  
어떤 데이터를 전달하면서 호출하는 방법이 있다

* 단순히 호출하는 방법은  
함수내에서 데이터를 만들고, 데이터를 연산하고, 데이터를 출력하는 대부분의 기능을 구현한다  
경우에 따라 전역적(public)으로 선언된 변수를 공유하면서  
연산을 수행하기도 한다  
전역변수를 공유하면서 연산을 수행하는 것은  
매우 불편한 코드가 만들어지고  
관리가 어렵고, 이후에 bug가 발생할 확률이 매 높다

* 데이터를 전달하면서 함수를 호출하는 방법은  
호출하는 곳에서 미리 데이터를 준비하고  
함수에서는 전달받은 데이터를 연산하여 출력하거나 또는 return

## 매개변수 전달방식
* Call by Value, Call By Reference, Call By Name 있다

### Call by Value
* java에서 함수에 직접 값을 전달하기  
add(300, 400)

* primitive 변수에 값을 담고, 전달하는 방식  
int num1 =300, num2 = 400  
add(num1, num2)

* 매개변수로 데이터를 전달받은 함수에서 데이터를 변환하여도  
원래 원본 데이터는 변함이 없다

* 프로그래밍에서 가장 안전한 데이터 전달 방식이다
* 연산된 결과를 return하지 않으면 어떻게 연산이 되었는지  
알수 있는 방법이 없다

### Call By Reference
* 함수에 매개변수를 전달할때 값을 전달하지 않고  
값이 저장된 기억장소의 주소를 전달하는 방식

* 우리집에 독특한 비빔밥을 만드는 레시피가 있다  
그 레시피에는 우리집만의 재로에 대한 정보가 있다  

* 친구가 우리집 비빔밥을 먹어보고 어떻게 만드는지 물어본다
* 말로서 주저리주저리 설명하지 않고  
우리집 주소를 알려주고 우리집 냉장고에 재료가 있으니  
만들어 먹어라 라고 한다
* 친구는 우리집에 방문하여 냉장고 안의 재로를 가지고  
비빔밥을 만들어 먹고  
재료를 모두 소진한것이 미안하여 한우 등심을 사서  
냉장고에 넣어둔다
* 저녁에 집에가서 비빔밥을 만들려고 냉장고를 열었더니  
재료가 바뀌었다

* Call by Reference로 데이터를 전달받은 함수에서  
변수의 값을 변경하면 원래 저장된 기억장소의 데이터가 변경되어  
호출하기 이전에 만들어진 변수가 값이 바뀌게 된다

* C/C++ 에서는 포인터라는 개념을 사용하여 Call By Reference를  
구현한다

* Java에서는 매개변수의 전달하는 개념이 모두 Call By Value이다  
다만 내부에 다른 요소를 포함하는 클래스(VO, List, Map)로  
생성한 변수를 함수에 매개변수로 전달하였을 경우  
함수에서 전달받은 변수의 일부 요소를 변경, 추가, 삭제하면  
원래 원본의 데이터에 변화가 생긴다  

* 단, 함수내에서 객체를 새로 생성(new ...)하면  
원본 데이터와 다른 데이터가 생성되는 결과가 되므로  
원본 데이터에는 변화가 없다

* Java는 클래스 type으로 변수를 만들때는 이런한 부분을  
상당히 신경써여 한다

* 다만, 이러한 기능을 십분 활용한 다양한 코드 방법이 있다
* 이러한 기능을 활용한 대표적인 코딩이  
Spring의 Controler 내의 함수들이다.

### Spring Controller의 함수들이 매개변수를 관리하는 방법
* 함수들을 선언할때 다양한 매개변수를 설정할 수 있다
* 종류, 개수에 관계없이 자유롭게 필요한 매개변수를 설정하면
* Spring Container는 Controller를 Bean을 생성할때
* 각 함수의 시그니처에 맞도록 호출 코드를 생성해 둔다  
void add(int num1, int num2), void add(String s1, String s2)

* 매개변수에 설정되는 클래스타입 변수중 일부는  
함수내에서 값을 변화(add, set, remove, clear)를 수행하면  
변수의 값이 변화되었다는 것을 Spring Container가 인지하고  
적절하게 반응한다.

* 그러한 클래스형 변수중 대표적으로 Model, HttpSession등이 있다


# HTTP Protocol, Web Service의 Session

## Session
* point to point 관계에서 한번 연결이 이루어지면  
파이프 라인과 같은 통로가 생성되고, 그 통로를 통하여  
데이터를 전송(주고 받기)하는 개념

* 예로) DBMS를 사용할때 사용자ID, Password를 사용하여 연결을 하면  
임의로 연결을 끊기 전까지 연결이 유지되어  
언제든지 명령을 보내고 데이터를 받을수 있다

## HTTP Protocol에서는 기본적으로 Session 이 없다
* stateless(상태가 없다)라고 표현한다
* client에서 Request를 보내면  
Server는 적절한 연산을 수행한 후 Reqponse를 하고  
연결이 즉시 종료된다.

## login 개념
* Web Service로 구현한 여러 페이지 중에서  
특정한 사용자 권한을 가진 경우만 볼수 있는 페이지가 있다고 하자

* client가 Request를 보내면, 사용자의 요청을 처리하기 전에  
권한을 가진 사용자 인지 검증을 하고  
검증이 정상이면 연산을 수행한 후 사용자에게 Reponse를 시켜야 한다.

* 이때 각 페이지마다 사용자의 정보를 수집하고, 인증하고, 정상인지 판단하여야 한다면  
많은 어려움과 불편함이 있을 것이다.

## HTTP Session
* 상태가 없는(상태가 유지 되지 않는) Web Service환경에서는  
접근하는 사용자 정보를 확인하기 위하여 매번 메뉴등을 클릭할때  
사용자정보를 입력하고 시작해야하는 방법으로 사용해야 한다  
* 매우 초창기 Web에서는 그러한 방법을 사용하기도 했다

* 이후에 HttpSession 이라는 개념이 탄생되고, 초기 기술로  
Cookie라는 기술이 생겨 났다.

* 사용자가 최초로 login기능을 요청하여 login이 허락되면  
서버에서 아주 작은 문자열 하나를 client에게 전달한다  
(Cookie : 기술적이 규격이 정해진 문자열)

* client 는 서버로 부터 Cookie가 전달되면 운영체제의 정해진  
폴더에 해당 파일을 저장해 놓는다  
Cookie에는 Server의 주소와 사용자 정보등이 기록되어 있다

* 이후에 client가 해당 Server에 Request를 보내면  
Browse는 Cookie가 저장된 폴더에서 해당 Server 정보가 담긴  
Cookie 가 있는지 검사한다

* 있으면 http protocol에 Cookie 정보를 같이 포함하여  
서버로 전송한다.

* Server에서는 http protocol에 Cookie정보가 담겨 있으면  
그 정보를 바탕으로 다시한번 인증을 수행한다

* 문제는 Cookie가 아무나 읽을 수 있는 일반(암호화 되지 않은) Text file 이다.
* 해커에 의해 언제든지 탈취될수 있고 변형될수 있는 매우 보안에 취약한 기술이다

* Cookie의 이러한 단점을 보완한 기술이 HttpSession이다

## HttpSession을 사용한 Session유지 기술
* login이 수행되어 정상적인 인증절차가 완료되면

* Server는 Session 객체를 하나 생성하여 서버 메모리에 저장한다  
* 여기에는 다양한 정보(속성, Attribute)를 포함하여 저장할수 있다.

* 그리고 이 메모리의 주소를 특별한 방법으로 Hash하여 ID 값을 만들어낸다. 이 값을 Session ID 라고 한다

* 이 Session ID를 Client에게 Cookie 형태로 전달한다
* 이후에 같은 Server에 Request를 보내면 Browser는 이 Session ID를 같이 Http Protocol에 실어서 보낸다.

* Cookie에 비하면 중요한 정보가 Server에 저장되므로 안전하다
* 단, Session이 많아 지면 서버의 메모리 사용량이 많아진다

* 이 HttpSession은 현존하는 Web Service에서 모두 지원하고  
가장 많이 사용하는 방법이다
* 또한 매우 쉽게 구현할수 있다














